<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            background: linear-gradient(135deg, #0c1a2d 0%, #1a3a5f 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            text-align: center;
            padding: 15px;
            z-index: 100;
            background: rgba(10, 25, 47, 0.85);
            border-bottom: 2px solid rgba(46, 229, 157, 0.4);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        h1 {
            color: #2ee59d;
            font-size: 2.2rem;
            text-shadow: 0 0 10px rgba(46, 229, 157, 0.5);
            margin-bottom: 8px;
        }
        .subtitle {
            color: #a3d9ff;
            font-size: 1rem;
            margin-bottom: 10px;
        }
        #controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        button {
            background: linear-gradient(to right, #2ee59d, #3a86ff);
            border: none;
            color: #0c1a2d;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(46, 229, 157, 0.4);
        }
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #viewer-container {
            flex: 3;
            position: relative;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        #camera-feed-container {
            flex: 1;
            min-width: 300px;
            background: #0a192f;
            display: flex;
            flex-direction: column;
            padding: 15px;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }
        .video-box {
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
            border: 2px solid #3a86ff;
            flex: 1;
            position: relative;
        }
        #camera-feed {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ï¼Œæ›´ç›´è§‚ */
        }
        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #stats {
            background: rgba(10, 25, 47, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.4;
            color: #a3d9ff;
        }
        #gesture-status {
            color: #2ee59d;
            font-weight: bold;
            font-size: 1.1rem;
            margin-top: 5px;
        }
        .instructions {
            background: rgba(58, 134, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #2ee59d;
        }
        .instructions h3 {
            color: #2ee59d;
            margin-bottom: 8px;
        }
        .instructions ul {
            padding-left: 20px;
        }
        .instructions li {
            margin-bottom: 5px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }
        .spinner {
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid #2ee59d;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .footer {
            text-align: center;
            padding: 10px;
            color: #7a9cc6;
            font-size: 0.8rem;
            background: rgba(10, 25, 47, 0.7);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>ğŸ„ æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘</h1>
        <p class="subtitle">ä½¿ç”¨ä½ çš„æ‰‹åŠ¿ä¸3Dåœ£è¯æ ‘è¿›è¡Œäº¤äº’ </p>
        <div id="controls">
            <button id="start-btn">ğŸš€ å¼€å§‹ä½“éªŒ</button>
            <button id="reset-btn">ğŸ”„ é‡ç½®ç²’å­</button>
            <button id="photo-btn">ğŸ“¸ ä¸Šä¼ ç…§ç‰‡ä½œä¸ºç²’å­</button>
            <button id="toggle-camera-btn">ğŸ“· åˆ‡æ¢æ‘„åƒå¤´</button>
        </div>
    </div>

    <div class="container">
        <!-- 3Dåœºæ™¯å®¹å™¨ -->
        <div id="viewer-container">
            <div id="loading">
                <div class="spinner"></div>
                <p>æ­£åœ¨åŠ è½½æ¨¡å‹ä¸ç›¸æœº...</p>
            </div>
        </div>

        <!-- æ‘„åƒå¤´å’Œæ‰‹åŠ¿è¯†åˆ«ç•Œé¢ -->
        <div id="camera-feed-container">
            <h3>ğŸ–ï¸ æ‰‹åŠ¿è¯†åˆ«åŒºåŸŸ</h3>
            <div class="video-box">
                <video id="camera-feed" autoplay playsinline></video>
                <canvas class="canvas-overlay" id="output-canvas"></canvas>
            </div>
            
            <div id="stats">
                <p><strong>å½“å‰çŠ¶æ€ï¼š</strong> <span id="gesture-status">ç­‰å¾…å¼€å§‹...</span></p>
                <p><strong>æ£€æµ‹åˆ°çš„æ‰‹åŠ¿ï¼š</strong> <span id="gesture-text">æ— </span></p>
                <p><strong>ç²’å­æ•°é‡ï¼š</strong> <span id="particle-count">0</span></p>
                <p><strong>äº¤äº’æç¤ºï¼š</strong> è¯·ç¡®ä¿æ‰‹éƒ¨åœ¨æ‘„åƒå¤´ç”»é¢å†…ï¼Œå…‰çº¿å……è¶³</p>
            </div>
            
            <div class="instructions">
                <h3>ğŸ® æ‰‹åŠ¿æ§åˆ¶æŒ‡å—</h3>
                <ul>
                    <li><strong>âœ‹ å¼ å¼€æ‰‹æŒ</strong>ï¼šç²’å­æ•£å¼€ï¼Œæ˜¾ç¤ºåœ£è¯æ ‘è½®å»“</li>
                    <li><strong>âœŠ æ¡ç´§æ‹³å¤´</strong>ï¼šç²’å­èšæ‹¢åˆ°ä¸­å¿ƒ</li>
                    <li><strong>ğŸ‘† ä¼¸å‡ºé£ŸæŒ‡</strong>ï¼šåˆ‡æ¢ç²’å­é¢œè‰²</li>
                    <li><strong>âœŒï¸ ä¼¸å‡ºä¸¤æŒ‡</strong>ï¼šåˆ‡æ¢ç²’å­è¿åŠ¨æ¨¡å¼</li>
                </ul>
                <p style="margin-top: 8px;">è°ƒæ•´æ‰‹ä¸æ‘„åƒå¤´çš„è·ç¦»å¯ä»¥æ§åˆ¶ç²’å­æ•£å¼€çš„ç¨‹åº¦ã€‚</p>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>æ‰‹åŠ¿äº¤äº’åœ£è¯æ ‘ | ä½¿ç”¨ Three.js å’Œ MediaPipe Hand Tracking æ„å»º | è¯·ä½¿ç”¨ Chrome æµè§ˆå™¨ä»¥è·å¾—æœ€ä½³ä½“éªŒ</p>
    </div>

    <!-- å¼•å…¥ Three.js åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ MediaPipe æ‰‹åŠ¿è¯†åˆ«åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <!-- å¼•å…¥ Tween.js ç”¨äºå¹³æ»‘åŠ¨ç”» -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, particles;
        let particleSystem, particlePositions = [], particleOriginalPositions = [];
        let particleCount = 2000;
        let isHandDetected = false;
        let currentGesture = 'none';
        let lastGestureChange = 0;
        let gestureCooldown = 500; // æ‰‹åŠ¿è¯†åˆ«å†·å´æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        let cameraStream = null;
        let currentCameraId = null;
        let photoTextures = [];
        let usePhotosAsParticles = false;
        let particleColors = [
            new THREE.Color(0x2ee59d), // ç»¿è‰²
            new THREE.Color(0xff6b6b), // çº¢è‰²
            new THREE.Color(0x4ecdc4), // é’è‰²
            new THREE.Color(0xffd166), // é»„è‰²
            new THREE.Color(0x9d4edd)  // ç´«è‰²
        ];
        let currentColorIndex = 0;
        let isSpiralMode = false;
        let spiralAngle = 0;

        // DOM å…ƒç´ 
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const photoBtn = document.getElementById('photo-btn');
        const toggleCameraBtn = document.getElementById('toggle-camera-btn');
        const gestureStatus = document.getElementById('gesture-status');
        const gestureText = document.getElementById('gesture-text');
        const particleCountElement = document.getElementById('particle-count');
        const loadingElement = document.getElementById('loading');
        const videoElement = document.getElementById('camera-feed');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        // åˆå§‹åŒ– Three.js 3D åœºæ™¯
        function initThreeJS() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0c1a2d);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, 
                document.getElementById('viewer-container').offsetWidth / 
                document.getElementById('viewer-container').offsetHeight, 
                0.1, 1000
            );
            camera.position.z = 15;
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            const container = document.getElementById('viewer-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // æ·»åŠ æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleTree();
            
            // æ·»åŠ ç®€å•çš„åœ£è¯æ ‘åº•åº§
            const baseGeometry = new THREE.ConeGeometry(5, 2, 8);
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -8;
            scene.add(base);
            
            // æ·»åŠ å‡ ä¸ªè£…é¥°çƒä½“
            const ornamentColors = [0xff0000, 0xff9900, 0xffff00, 0x00ff00, 0x0000ff];
            for(let i = 0; i < 8; i++) {
                const radius = 0.3;
                const geometry = new THREE.SphereGeometry(radius, 16, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: ornamentColors[i % ornamentColors.length],
                    emissive: ornamentColors[i % ornamentColors.length],
                    emissiveIntensity: 0.2
                });
                const ornament = new THREE.Mesh(geometry, material);
                
                // å°†è£…é¥°çƒæ”¾åœ¨æ ‘ä¸Š
                const angle = (i / 8) * Math.PI * 2;
                const height = -4 + (i % 4) * 2.5;
                const distance = 2.5 - (i % 3) * 0.7;
                ornament.position.x = Math.cos(angle) * distance;
                ornament.position.y = height;
                ornament.position.z = Math.sin(angle) * distance;
                
                scene.add(ornament);
            }
            
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', onWindowResize);
            
            // æ›´æ–°ç²’å­è®¡æ•°æ˜¾ç¤º
            particleCountElement.textContent = particleCount;
        }
        
        // åˆ›å»ºåœ£è¯æ ‘å½¢çŠ¶çš„ç²’å­ç³»ç»Ÿ
        function createParticleTree() {
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: particleColors[currentColorIndex],
                size: 0.1,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            particlePositions = [];
            particleOriginalPositions = [];
            
            // åˆ›å»ºåœ£è¯æ ‘å½¢çŠ¶çš„ç²’å­
            for(let i = 0; i < particleCount; i++) {
                // ç”Ÿæˆæ ‘å½¢ç»“æ„çš„ç²’å­ä½ç½®
                let x, y, z;
                
                // æ ‘å¹²éƒ¨åˆ† (åº•éƒ¨20%çš„ç²’å­)
                if(i < particleCount * 0.2) {
                    const radius = 0.5;
                    const angle = Math.random() * Math.PI * 2;
                    x = Math.cos(angle) * radius * Math.random();
                    y = -7 + Math.random() * 1.5;
                    z = Math.sin(angle) * radius * Math.random();
                }
                // æ ‘ä½“éƒ¨åˆ†
                else {
                    // æ ¹æ®é«˜åº¦ç¡®å®šåŠå¾„
                    const heightRatio = (i - particleCount * 0.2) / (particleCount * 0.8);
                    const height = -5 + heightRatio * 10; // ä»-5åˆ°5
                    
                    // æ ‘å† åŠå¾„éšé«˜åº¦å‡å°
                    const maxRadius = 4 * (1 - heightRatio * 0.7);
                    const radius = maxRadius * Math.sqrt(Math.random());
                    
                    const angle = Math.random() * Math.PI * 2;
                    x = Math.cos(angle) * radius;
                    y = height;
                    z = Math.sin(angle) * radius;
                    
                    // æ·»åŠ ä¸€äº›éšæœºæ€§ä½¿æ ‘çœ‹èµ·æ¥æ›´è‡ªç„¶
                    x += (Math.random() - 0.5) * 0.5;
                    z += (Math.random() - 0.5) * 0.5;
                }
                
                particlePositions.push(x, y, z);
                particleOriginalPositions.push(x, y, z);
            }
            
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
        }
        
        // é‡ç½®ç²’å­ä½ç½®
        function resetParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            
            for(let i = 0; i < positions.length; i += 3) {
                positions[i] = particleOriginalPositions[i];
                positions[i+1] = particleOriginalPositions[i+1];
                positions[i+2] = particleOriginalPositions[i+2];
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            gestureStatus.textContent = 'ç²’å­å·²é‡ç½®';
            gestureStatus.style.color = '#2ee59d';
        }
        
        // æ ¹æ®æ‰‹åŠ¿æ›´æ–°ç²’å­
        function updateParticlesBasedOnGesture() {
            if(!particleSystem || currentGesture === 'none') return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const time = Date.now() * 0.001; // è½¬æ¢ä¸ºç§’
            
            if(currentGesture === 'open' || currentGesture === 'victory') {
                // å¼ å¼€æ‰‹æŒæˆ–å‰ªåˆ€æ‰‹ï¼šç²’å­å‘å¤–æ•£å¼€
                const spreadIntensity = currentGesture === 'open' ? 1.2 : 0.8;
                
                for(let i = 0; i < positions.length; i += 3) {
                    const originalX = particleOriginalPositions[i];
                    const originalY = particleOriginalPositions[i+1];
                    const originalZ = particleOriginalPositions[i+2];
                    
                    // æ·»åŠ ä¸€äº›æ³¢åŠ¨æ•ˆæœ
                    const waveX = Math.sin(time * 2 + originalY * 0.5) * 0.3;
                    const waveY = Math.cos(time * 1.5 + originalX * 0.3) * 0.2;
                    const waveZ = Math.sin(time * 1.8 + originalZ * 0.4) * 0.3;
                    
                    // é€æ¸ç§»åŠ¨åˆ°åŸå§‹ä½ç½®é™„è¿‘ï¼ˆå¸¦æ³¢åŠ¨ï¼‰
                    positions[i] += (originalX + waveX - positions[i]) * 0.05 * spreadIntensity;
                    positions[i+1] += (originalY + waveY - positions[i+1]) * 0.05 * spreadIntensity;
                    positions[i+2] += (originalZ + waveZ - positions[i+2]) * 0.05 * spreadIntensity;
                }
                
                if(currentGesture === 'victory') {
                    // å‰ªåˆ€æ‰‹æ—¶æ·»åŠ æ—‹è½¬æ•ˆæœ
                    particleSystem.rotation.y += 0.01;
                }
            }
            else if(currentGesture === 'closed' || currentGesture === 'pointing') {
                // æ¡æ‹³æˆ–ä¼¸é£ŸæŒ‡ï¼šç²’å­å‘ä¸­å¿ƒèšæ‹¢
                const centerIntensity = currentGesture === 'closed' ? 1.5 : 1.0;
                
                for(let i = 0; i < positions.length; i += 3) {
                    const originalX = particleOriginalPositions[i];
                    const originalY = particleOriginalPositions[i+1];
                    const originalZ = particleOriginalPositions[i+2];
                    
                    // è®¡ç®—å‘ä¸­å¿ƒèšæ‹¢çš„ç›®æ ‡ä½ç½®
                    const targetX = originalX * 0.1;
                    const targetY = originalY * 0.1;
                    const targetZ = originalZ * 0.1;
                    
                    // æ·»åŠ ä¸€äº›éšæœºè¿åŠ¨
                    const randomX = (Math.random() - 0.5) * 0.1;
                    const randomY = (Math.random() - 0.5) * 0.1;
                    const randomZ = (Math.random() - 0.5) * 0.1;
                    
                    positions[i] += (targetX + randomX - positions[i]) * 0.03 * centerIntensity;
                    positions[i+1] += (targetY + randomY - positions[i+1]) * 0.03 * centerIntensity;
                    positions[i+2] += (targetZ + randomZ - positions[i+2]) * 0.03 * centerIntensity;
                }
                
                if(currentGesture === 'pointing') {
                    // ä¼¸é£ŸæŒ‡æ—¶æ·»åŠ èºæ—‹æ•ˆæœ
                    spiralAngle += 0.05;
                    for(let i = 0; i < positions.length; i += 3) {
                        const radius = Math.sqrt(
                            positions[i] * positions[i] + 
                            positions[i+2] * positions[i+2]
                        );
                        const angle = Math.atan2(positions[i+2], positions[i]) + 0.02;
                        
                        positions[i] = radius * Math.cos(angle);
                        positions[i+2] = radius * Math.sin(angle);
                    }
                }
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            
            // å¦‚æœæ˜¯èºæ—‹æ¨¡å¼ï¼Œæ·»åŠ é¢å¤–æ—‹è½¬
            if(isSpiralMode) {
                particleSystem.rotation.y += 0.005;
                particleSystem.rotation.x = Math.sin(time * 0.5) * 0.1;
            }
        }
        
        // åˆ‡æ¢ç²’å­é¢œè‰²
        function changeParticleColor() {
            currentColorIndex = (currentColorIndex + 1) % particleColors.length;
            particleSystem.material.color = particleColors[currentColorIndex];
            gestureStatus.textContent = `é¢œè‰²åˆ‡æ¢ä¸º ${currentColorIndex + 1} å·`;
            gestureStatus.style.color = particleColors[currentColorIndex].getStyle();
        }
        
        // åˆ‡æ¢èºæ—‹æ¨¡å¼
        function toggleSpiralMode() {
            isSpiralMode = !isSpiralMode;
            gestureStatus.textContent = isSpiralMode ? 'èºæ—‹æ¨¡å¼å·²å¼€å¯' : 'èºæ—‹æ¨¡å¼å·²å…³é—­';
            gestureStatus.style.color = '#3a86ff';
        }
        
        // çª—å£å¤§å°å˜åŒ–å¤„ç†
        function onWindowResize() {
            const container = document.getElementById('viewer-container');
            camera.aspect = container.offsetWidth / container.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.offsetWidth, container.offsetHeight);
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°ç²’å­ä½ç½®
            updateParticlesBasedOnGesture();
            
            // æ·»åŠ ç›¸æœºè½»å¾®åŠ¨ç”»
            const time = Date.now() * 0.001;
            camera.position.x = Math.sin(time * 0.2) * 2;
            camera.position.z = 15 + Math.cos(time * 0.3) * 1;
            camera.lookAt(0, 0, 0);
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }
        
        // åˆå§‹åŒ– MediaPipe æ‰‹åŠ¿è¯†åˆ«
        function initHandTracking() {
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onHandResults);
            
            // å¯åŠ¨ç›¸æœº
            startCamera(hands);
        }
        
        // å¤„ç†æ‰‹åŠ¿è¯†åˆ«ç»“æœ
        function onHandResults(results) {
            // ç»˜åˆ¶ç›¸æœºç”»é¢å’Œæ‰‹éƒ¨å…³é”®ç‚¹
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹å’Œè¿æ¥çº¿
                for(const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                        color: '#2ee59d',
                        lineWidth: 2
                    });
                    drawLandmarks(canvasCtx, landmarks, {
                        color: '#FF0000',
                        lineWidth: 1,
                        radius: 3
                    });
                }
                
                // æ£€æµ‹æ‰‹åŠ¿
                detectGesture(results.multiHandLandmarks[0]);
                isHandDetected = true;
            } else {
                isHandDetected = false;
                if(Date.now() - lastGestureChange > 1000) {
                    currentGesture = 'none';
                    updateGestureDisplay();
                }
            }
            
            canvasCtx.restore();
        }
        
        // æ£€æµ‹å…·ä½“æ‰‹åŠ¿
        function detectGesture(landmarks) {
            if(!landmarks || landmarks.length < 21) return;
            
            // è·å–å…³é”®æ‰‹æŒ‡çš„æŒ‡å°–å’ŒæŒ‡æ ¹ä½ç½®
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            
            const wrist = landmarks[0];
            
            // è®¡ç®—æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´
            const isThumbExtended = thumbTip.y < landmarks[3].y;
            const isIndexExtended = indexTip.y < landmarks[6].y;
            const isMiddleExtended = middleTip.y < landmarks[10].y;
            const isRingExtended = ringTip.y < landmarks[14].y;
            const isPinkyExtended = pinkyTip.y < landmarks[18].y;
            
            // è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
            const indexTipDistance = Math.sqrt(
                Math.pow(indexTip.x - wrist.x, 2) + 
                Math.pow(indexTip.y - wrist.y, 2)
            );
            
            // æ£€æµ‹ä¸åŒæ‰‹åŠ¿
            let detectedGesture = 'none';
            
            // å¼ å¼€æ‰‹æŒï¼šæ‰€æœ‰æ‰‹æŒ‡éƒ½ä¼¸ç›´
            if(isIndexExtended && isMiddleExtended && isRingExtended && isPinkyExtended) {
                detectedGesture = 'open';
            }
            // æ¡æ‹³ï¼šæ‰€æœ‰æ‰‹æŒ‡éƒ½ä¸ä¼¸ç›´
            else if(!isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                detectedGesture = 'closed';
            }
            // ä¼¸é£ŸæŒ‡ï¼šåªæœ‰é£ŸæŒ‡ä¼¸ç›´
            else if(isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                detectedGesture = 'pointing';
            }
            // å‰ªåˆ€æ‰‹ï¼šé£ŸæŒ‡å’Œä¸­æŒ‡ä¼¸ç›´
            else if(isIndexExtended && isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                detectedGesture = 'victory';
            }
            
            // æ›´æ–°æ‰‹åŠ¿ï¼ˆé˜²æ­¢é¢‘ç¹åˆ‡æ¢ï¼‰
            if(detectedGesture !== currentGesture && 
               Date.now() - lastGestureChange > gestureCooldown) {
                currentGesture = detectedGesture;
                lastGestureChange = Date.now();
                updateGestureDisplay();
                
                // æ ¹æ®æ‰‹åŠ¿è§¦å‘ç‰¹å®šåŠŸèƒ½
                if(currentGesture === 'pointing') {
                    changeParticleColor();
                } else if(currentGesture === 'victory') {
                    toggleSpiralMode();
                }
            }
        }
        
        // æ›´æ–°æ‰‹åŠ¿æ˜¾ç¤º
        function updateGestureDisplay() {
            const gestureNames = {
                'none': 'æœªæ£€æµ‹åˆ°æ‰‹åŠ¿',
                'open': 'âœ‹ å¼ å¼€æ‰‹æŒ',
                'closed': 'âœŠ æ¡ç´§æ‹³å¤´',
                'pointing': 'ğŸ‘† ä¼¸é£ŸæŒ‡',
                'victory': 'âœŒï¸ å‰ªåˆ€æ‰‹'
            };
            
            gestureText.textContent = gestureNames[currentGesture] || 'æœªçŸ¥æ‰‹åŠ¿';
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            if(currentGesture === 'open') {
                gestureStatus.textContent = 'ç²’å­æ­£åœ¨æ•£å¼€...';
                gestureStatus.style.color = '#2ee59d';
            } else if(currentGesture === 'closed') {
                gestureStatus.textContent = 'ç²’å­æ­£åœ¨èšæ‹¢...';
                gestureStatus.style.color = '#ff6b6b';
            } else if(currentGesture === 'pointing') {
                gestureStatus.textContent = 'å·²åˆ‡æ¢é¢œè‰²';
                gestureStatus.style.color = '#ffd166';
            } else if(currentGesture === 'victory') {
                gestureStatus.textContent = 'å·²åˆ‡æ¢æ¨¡å¼';
                gestureStatus.style.color = '#9d4edd';
            } else {
                gestureStatus.textContent = 'ç­‰å¾…æ‰‹åŠ¿...';
                gestureStatus.style.color = '#a3d9ff';
            }
        }
        
        // å¯åŠ¨ç›¸æœº
        function startCamera(hands) {
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            camera.start();
            
            // è®¾ç½®canvaså°ºå¯¸
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            
            // éšè—åŠ è½½ç•Œé¢
            loadingElement.style.display = 'none';
        }
        
        // è·å–æ‘„åƒå¤´è®¾å¤‡åˆ—è¡¨
        async function getCameraDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                return devices.filter(device => device.kind === 'videoinput');
            } catch(err) {
                console.error('è·å–æ‘„åƒå¤´è®¾å¤‡å¤±è´¥:', err);
                return [];
            }
        }
        
        // åˆ‡æ¢æ‘„åƒå¤´
        async function toggleCamera() {
            try {
                const cameras = await getCameraDevices();
                if(cameras.length < 2) {
                    alert('æœªæ‰¾åˆ°å¤šä¸ªæ‘„åƒå¤´è®¾å¤‡');
                    return;
                }
                
                // åœæ­¢å½“å‰æ‘„åƒå¤´
                if(cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                }
                
                // åˆ‡æ¢æ‘„åƒå¤´ID
                const currentIndex = cameras.findIndex(cam => 
                    cam.deviceId === currentCameraId
                );
                const nextIndex = (currentIndex + 1) % cameras.length;
                currentCameraId = cameras[nextIndex].deviceId;
                
                // å¯åŠ¨æ–°æ‘„åƒå¤´
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        deviceId: { exact: currentCameraId },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                
                videoElement.srcObject = cameraStream;
                gestureStatus.textContent = `å·²åˆ‡æ¢åˆ°æ‘„åƒå¤´ ${nextIndex + 1}`;
                gestureStatus.style.color = '#3a86ff';
            } catch(err) {
                console.error('åˆ‡æ¢æ‘„åƒå¤´å¤±è´¥:', err);
                alert('åˆ‡æ¢æ‘„åƒå¤´å¤±è´¥: ' + err.message);
            }
        }
        
        // ä¸Šä¼ ç…§ç‰‡ä½œä¸ºç²’å­
        function uploadPhotoForParticles() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.multiple = true;
            
            input.onchange = async (e) => {
                const files = Array.from(e.target.files);
                if(files.length === 0) return;
                
                gestureStatus.textContent = 'æ­£åœ¨å¤„ç†ç…§ç‰‡...';
                gestureStatus.style.color = '#ffd166';
                
                // é™åˆ¶æœ€å¤šåŠ è½½5å¼ ç…§ç‰‡
                const filesToLoad = files.slice(0, 5);
                
                for(const file of filesToLoad) {
                    try {
                        const texture = await createTextureFromFile(file);
                        photoTextures.push(texture);
                    } catch(err) {
                        console.error('åˆ›å»ºçº¹ç†å¤±è´¥:', err);
                    }
                }
                
                if(photoTextures.length > 0) {
                    usePhotosAsParticles = true;
                    applyPhotoTextures();
                    gestureStatus.textContent = `å·²åŠ è½½ ${photoTextures.length} å¼ ç…§ç‰‡ä½œä¸ºç²’å­`;
                    gestureStatus.style.color = '#9d4edd';
                }
            };
            
            input.click();
        }
        
        // ä»æ–‡ä»¶åˆ›å»ºçº¹ç†
        function createTextureFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new THREE.FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // è°ƒæ•´å›¾ç‰‡å¤§å°ä»¥ä¼˜åŒ–æ€§èƒ½
                        const maxSize = 128;
                        let width = img.width, height = img.height;
                        
                        if(width > height) {
                            height = (maxSize / width) * height;
                            width = maxSize;
                        } else {
                            width = (maxSize / height) * width;
                            height = maxSize;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        resolve(texture);
                    };
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // åº”ç”¨ç…§ç‰‡çº¹ç†åˆ°ç²’å­
        function applyPhotoTextures() {
            if(photoTextures.length === 0) return;
            
            // åˆ›å»ºä½¿ç”¨çº¹ç†çš„ç²’å­æè´¨
            const textureMaterial = new THREE.PointsMaterial({
                map: photoTextures[0], // ä½¿ç”¨ç¬¬ä¸€å¼ ç…§ç‰‡
                size: 0.15,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true,
                alphaTest: 0.1
            });
            
            // æ›¿æ¢ç²’å­æè´¨
            scene.remove(particleSystem);
            particleSystem.material = textureMaterial;
            scene.add(particleSystem);
            
            // å®šæœŸåˆ‡æ¢çº¹ç†
            let textureIndex = 0;
            setInterval(() => {
                if(photoTextures.length > 1) {
                    textureIndex = (textureIndex + 1) % photoTextures.length;
                    particleSystem.material.map = photoTextures[textureIndex];
                    particleSystem.material.needsUpdate = true;
                }
            }, 2000); // æ¯2ç§’åˆ‡æ¢ä¸€æ¬¡çº¹ç†
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', () => {
            // åˆå§‹åŒ– Three.js
            initThreeJS();
            
            // è®¾ç½®æŒ‰é’®äº‹ä»¶
            startBtn.addEventListener('click', () => {
                gestureStatus.textContent = 'å¼€å§‹æ‰‹åŠ¿è¯†åˆ«...';
                gestureStatus.style.color = '#2ee59d';
                initHandTracking();
            });
            
            resetBtn.addEventListener('click', resetParticles);
            
            photoBtn.addEventListener('click', uploadPhotoForParticles);
            
            toggleCameraBtn.addEventListener('click', toggleCamera);
            
            // è‡ªåŠ¨å¼€å§‹åŠ¨ç”»
            animate();
            
            // å°è¯•è‡ªåŠ¨å¯åŠ¨æ‘„åƒå¤´ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’åï¼‰
            startBtn.addEventListener('click', () => {
                setTimeout(() => {
                    if(!isHandDetected) {
                        gestureStatus.textContent = 'è¯·ç¡®ä¿æ‘„åƒå¤´å·²å¯ç”¨ä¸”æ‰‹éƒ¨åœ¨ç”»é¢ä¸­';
                        gestureStatus.style.color = '#ff6b6b';
                    }
                }, 3000);
            });
            
            // åˆå§‹çŠ¶æ€
            gestureStatus.textContent = 'ç‚¹å‡»"å¼€å§‹ä½“éªŒ"æŒ‰é’®å¯åŠ¨';
            gestureStatus.style.color = '#a3d9ff';
        });
        
        // å·¥å…·å‡½æ•°ï¼šè®¡ç®—ä¸¤ç‚¹ä¹‹é—´è·ç¦»
        function distance(point1, point2) {
            return Math.sqrt(
                Math.pow(point1.x - point2.x, 2) + 
                Math.pow(point1.y - point2.y, 2)
            );
        }
    </script>
</body>
</html>