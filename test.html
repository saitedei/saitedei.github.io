<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®€å•æ‰‹åŠ¿åœ£è¯æ ‘</title>
    <style>
        * { margin: 0; padding: 0; }
        body { 
            background: #0c1a2d; 
            color: white;
            font-family: Arial;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .header {
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.5);
        }
        h1 { color: #2ee59d; font-size: 1.5rem; }
        #scene { flex: 1; position: relative; }
        #camera-area {
            height: 180px;
            background: black;
            position: relative;
            border-top: 3px solid #2ee59d;
        }
        video, canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        canvas { position: absolute; top: 0; left: 0; }
        .controls {
            padding: 10px;
            background: rgba(0,0,0,0.7);
            display: flex;
            gap: 10px;
        }
        button {
            flex: 1;
            padding: 12px;
            background: #2ee59d;
            border: none;
            color: #0c1a2d;
            font-weight: bold;
            border-radius: 20px;
        }
        .status {
            padding: 10px;
            text-align: center;
            font-size: 1.2rem;
        }
        #debug {
            padding: 10px;
            background: rgba(255,0,0,0.1);
            font-size: 0.8rem;
            display: none;
        }
        .gesture-emoji {
            font-size: 2rem;
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ„ ç®€å•æ‰‹åŠ¿æµ‹è¯•</h1>
            <p id="subtitle">ç‚¹å‡»"å¼€å§‹"åï¼Œè¯·å…è®¸æ‘„åƒå¤´æƒé™</p>
        </div>
        
        <div id="scene">
            <!-- 3Dåœºæ™¯å°†é€šè¿‡Three.jsæ¸²æŸ“åˆ°è¿™é‡Œ -->
        </div>
        
        <div class="status">
            <div id="status-text">å‡†å¤‡ä¸­...</div>
            <div class="gesture-emoji" id="gesture-emoji">ğŸ–ï¸</div>
        </div>
        
        <div id="camera-area">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
        </div>
        
        <div id="debug">
            è°ƒè¯•ä¿¡æ¯: <span id="debug-text">ç­‰å¾…å¯åŠ¨</span>
        </div>
        
        <div class="controls">
            <button id="start-btn">ğŸš€ å¼€å§‹è¯†åˆ«</button>
            <button id="debug-btn">ğŸ› è°ƒè¯•æ¨¡å¼</button>
        </div>
    </div>

    <!-- ä»…åŠ è½½æœ€å¿…è¦çš„åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <script>
        // è°ƒè¯•æ¨¡å¼
        let debugMode = false;
        const debugEl = document.getElementById('debug');
        const debugText = document.getElementById('debug-text');
        
        // çŠ¶æ€æ˜¾ç¤º
        const statusText = document.getElementById('status-text');
        const gestureEmoji = document.getElementById('gesture-emoji');
        const subtitle = document.getElementById('subtitle');
        
        // æ‰‹åŠ¿çŠ¶æ€
        let currentGesture = 'none';
        let hands = null;
        let camera = null;
        
        // åˆå§‹åŒ–Three.jsç®€å•åœºæ™¯
        function initSimpleScene() {
            const sceneEl = document.getElementById('scene');
            
            // åˆ›å»ºåœºæ™¯
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a192f);
            
            // ç›¸æœº
            const camera = new THREE.PerspectiveCamera(75, sceneEl.clientWidth / sceneEl.clientHeight, 0.1, 1000);
            camera.position.z = 15;
            
            // æ¸²æŸ“å™¨
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(sceneEl.clientWidth, sceneEl.clientHeight);
            sceneEl.appendChild(renderer.domElement);
            
            // åˆ›å»ºç®€å•åœ£è¯æ ‘ï¼ˆä½¿ç”¨åŸºç¡€å‡ ä½•ä½“ï¼‰
            createSimpleTree(scene);
            
            // ç¯å¢ƒå…‰
            const light = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(light);
            
            // æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 0);
            scene.add(directionalLight);
            
            // åŠ¨ç”»å¾ªç¯
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();
            
            updateDebug('3Dåœºæ™¯åˆå§‹åŒ–å®Œæˆ');
        }
        
        function createSimpleTree(scene) {
            // æ ‘å¹²
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 3, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = -3;
            scene.add(trunk);
            
            // æ ‘å† ï¼ˆä¸‰å±‚ï¼‰
            const treeColors = [0x2ecc71, 0x27ae60, 0x229954];
            for(let i = 0; i < 3; i++) {
                const coneGeometry = new THREE.ConeGeometry(2 + i * 0.5, 3, 8);
                const coneMaterial = new THREE.MeshPhongMaterial({ color: treeColors[i] });
                const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                cone.position.y = i * 2.5;
                scene.add(cone);
            }
            
            // è£…é¥°çƒ
            const ballColors = [0xe74c3c, 0xf1c40f, 0x3498db, 0x9b59b6];
            for(let i = 0; i < 8; i++) {
                const ballGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const ballMaterial = new THREE.MeshPhongMaterial({ color: ballColors[i % 4] });
                const ball = new THREE.Mesh(ballGeometry, ballMaterial);
                
                const angle = (i / 8) * Math.PI * 2;
                const radius = 1.2;
                ball.position.x = Math.cos(angle) * radius;
                ball.position.z = Math.sin(angle) * radius;
                ball.position.y = -1 + i * 0.8;
                
                scene.add(ball);
            }
        }
        
        // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
        function initHandTracking() {
            updateStatus('æ­£åœ¨åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«...', 'âš™ï¸');
            
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,  // ä½¿ç”¨è½»é‡æ¨¡å‹
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5,
                selfieMode: true
            });
            
            hands.onResults(onResults);
            
            // å¯åŠ¨æ‘„åƒå¤´
            startCamera();
        }
        
        function startCamera() {
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            canvas.width = video.clientWidth;
            canvas.height = video.clientHeight;
            
            navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'user',
                    width: { ideal: 320 },
                    height: { ideal: 240 }
                }
            }).then(stream => {
                video.srcObject = stream;
                
                camera = new Camera(video, {
                    onFrame: async () => {
                        await hands.send({ image: video });
                    },
                    width: 320,
                    height: 240
                });
                
                camera.start();
                
                updateStatus('æ‘„åƒå¤´å·²å¯åŠ¨ï¼è¯·å°†æ‰‹æ”¾åœ¨ç”»é¢ä¸­', 'ğŸ“±');
                updateDebug('æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ');
                
            }).catch(err => {
                updateStatus('æ‘„åƒå¤´è®¿é—®å¤±è´¥: ' + err.message, 'âŒ');
                updateDebug('æ‘„åƒå¤´é”™è¯¯: ' + err.message);
            });
        }
        
        function onResults(results) {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if(results.image) {
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            }
            
            if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹ï¼ˆç®€å•ç‰ˆï¼‰
                const landmarks = results.multiHandLandmarks[0];
                
                // ç»˜åˆ¶æ‰€æœ‰å…³é”®ç‚¹
                for(let i = 0; i < landmarks.length; i++) {
                    const x = landmarks[i].x * canvas.width;
                    const y = landmarks[i].y * canvas.height;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#2ee59d';
                    ctx.fill();
                }
                
                // æ£€æµ‹æ‰‹åŠ¿ï¼ˆç®€åŒ–é€»è¾‘ï¼‰
                detectSimpleGesture(landmarks);
                
                if(debugMode) {
                    updateDebug(`æ£€æµ‹åˆ°æ‰‹éƒ¨ï¼Œå…³é”®ç‚¹æ•°é‡: ${landmarks.length}`);
                }
            } else {
                currentGesture = 'none';
                updateGestureDisplay();
                
                if(debugMode) {
                    updateDebug('æœªæ£€æµ‹åˆ°æ‰‹éƒ¨');
                }
            }
        }
        
        function detectSimpleGesture(landmarks) {
            if(!landmarks || landmarks.length < 21) return;
            
            // è·å–å…³é”®ç‚¹ç´¢å¼•
            const landmarksIndex = {
                wrist: 0,
                thumb: [1, 2, 3, 4],
                index: [5, 6, 7, 8],
                middle: [9, 10, 11, 12],
                ring: [13, 14, 15, 16],
                pinky: [17, 18, 19, 20]
            };
            
            // æŒ‡å°–ç‚¹
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            
            // åˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ï¼ˆç®€å•æ–¹æ³•ï¼šyåæ ‡æ¯”è¾ƒï¼‰
            const isIndexStraight = indexTip.y < landmarks[6].y;
            const isMiddleStraight = middleTip.y < landmarks[10].y;
            const isRingStraight = ringTip.y < landmarks[14].y;
            const isPinkyStraight = pinkyTip.y < landmarks[18].y;
            
            let gesture = 'none';
            
            // æ‰‹åŠ¿åˆ¤æ–­é€»è¾‘
            if(isIndexStraight && isMiddleStraight && isRingStraight && isPinkyStraight) {
                gesture = 'open';
            } else if(!isIndexStraight && !isMiddleStraight && !isRingStraight && !isPinkyStraight) {
                gesture = 'closed';
            } else if(isIndexStraight && !isMiddleStraight && !isRingStraight && !isPinkyStraight) {
                gesture = 'pointing';
            } else if(isIndexStraight && isMiddleStraight && !isRingStraight && !isPinkyStraight) {
                gesture = 'victory';
            }
            
            // æ›´æ–°æ‰‹åŠ¿æ˜¾ç¤º
            if(gesture !== currentGesture) {
                currentGesture = gesture;
                updateGestureDisplay();
            }
        }
        
        function updateGestureDisplay() {
            const gestureInfo = {
                'none': { text: 'ç­‰å¾…æ‰‹åŠ¿...', emoji: 'ğŸ–ï¸', color: '#a3d9ff' },
                'open': { text: 'å¼ å¼€æ‰‹æŒ', emoji: 'âœ‹', color: '#2ee59d' },
                'closed': { text: 'æ¡ç´§æ‹³å¤´', emoji: 'âœŠ', color: '#ff6b6b' },
                'pointing': { text: 'ä¼¸å‡ºé£ŸæŒ‡', emoji: 'ğŸ‘†', color: '#ffd166' },
                'victory': { text: 'å‰ªåˆ€æ‰‹', emoji: 'âœŒï¸', color: '#9d4edd' }
            };
            
            const info = gestureInfo[currentGesture] || gestureInfo.none;
            
            statusText.textContent = info.text;
            statusText.style.color = info.color;
            gestureEmoji.textContent = info.emoji;
            
            if(debugMode) {
                updateDebug(`æ‰‹åŠ¿: ${info.text}`);
            }
        }
        
        function updateStatus(text, emoji) {
            statusText.textContent = text;
            if(emoji) gestureEmoji.textContent = emoji;
        }
        
        function updateDebug(text) {
            debugText.textContent = text;
        }
        
        // é¡µé¢åŠ è½½
        document.addEventListener('DOMContentLoaded', () => {
            // åˆå§‹åŒ–åœºæ™¯
            initSimpleScene();
            
            // æŒ‰é’®äº‹ä»¶
            document.getElementById('start-btn').addEventListener('click', () => {
                subtitle.textContent = 'è¯·ç¡®ä¿å…è®¸æ‘„åƒå¤´æƒé™';
                initHandTracking();
            });
            
            document.getElementById('debug-btn').addEventListener('click', () => {
                debugMode = !debugMode;
                debugEl.style.display = debugMode ? 'block' : 'none';
                updateDebug('è°ƒè¯•æ¨¡å¼ ' + (debugMode ? 'å¼€å¯' : 'å…³é—­'));
            });
            
            // åˆå§‹çŠ¶æ€
            updateStatus('ç‚¹å‡»"å¼€å§‹è¯†åˆ«"æŒ‰é’®å¯åŠ¨', 'â–¶ï¸');
        });
    </script>
</body>
</html>